#!/usr/bin/env python3
#################################################################
# YPSH Language - Your route of Programming is Starting from Here
# Installer / Updater
# MIT License
# Copyright (c) 2025 DiamondGotCat
# Generated by LLM
#################################################################

from __future__ import annotations

import os
import sys
import platform
import tempfile
import shutil
import zipfile
import traceback
from dataclasses import dataclass
from typing import Literal, Dict, Any, Callable, Optional

import requests
from rich import print

# ─────────────────────────────────────────────────────────────────────────────
# Shared install logic (unchanged)
# ─────────────────────────────────────────────────────────────────────────────

Channel = Literal["stable", "beta", "custom"]
DEFAULT_DEST = os.path.join(os.path.expanduser("~"), ".ypsh", "bin")


def passingGatekeeper(path: str) -> None:
    try:
        os.system(f"xattr -d com.apple.quarantine '{path}'")
    except Exception:
        pass


def getTagFromChannel(id: str) -> str:
    base = "https://ypsh-dgc.github.io/YPSH/channels/"
    return requests.get(f"{base}{id}.txt", timeout=10).text.strip()


def getAutoBuildInfomation(tag: str) -> Dict[str, Any]:
    system = platform.system()
    arch = platform.machine()

    def err(msg):
        return {"status": "error", "desc": msg}

    if system == "Darwin":
        if arch.lower() in ("x86_64", "amd64"):
            dl = f"https://github.com/YPSH-DGC/YPSH/releases/download/{tag}/YPSH-macos-amd64.zip"
            origin, friendly = "YPSH-macos-amd64", "macOS Intel"
        elif arch.lower() in ("arm64", "aarch64"):
            dl = f"https://github.com/YPSH-DGC/YPSH/releases/download/{tag}/YPSH-macos-arm64.zip"
            origin, friendly = "YPSH-macos-arm64", "macOS Apple Silicon"
        else:
            return err(f"Unsupported CPU: {arch}")
        final, gate = "ypsh", True
    elif system == "Linux":
        if arch.lower() in ("x86_64", "amd64"):
            dl = f"https://github.com/YPSH-DGC/YPSH/releases/download/{tag}/YPSH-linux-amd64.zip"
            origin, friendly = "YPSH-linux-amd64", "Linux Intel/AMD"
        elif arch.lower() in ("arm64", "aarch64"):
            dl = f"https://github.com/YPSH-DGC/YPSH/releases/download/{tag}/YPSH-linux-arm64.zip"
            origin, friendly = "YPSH-linux-arm64", "Linux ARM"
        else:
            return err(f"Unsupported CPU: {arch}")
        final, gate = "ypsh", False
    elif system == "Windows":
        if arch.lower() in ("x86_64", "amd64"):
            dl = f"https://github.com/YPSH-DGC/YPSH/releases/download/{tag}/YPSH-windows-amd64.zip"
            origin, friendly = "YPSH-windows-amd64.exe", "Windows Intel/AMD"
        elif arch.lower() in ("arm64", "aarch64"):
            dl = f"https://github.com/YPSH-DGC/YPSH/releases/download/{tag}/YPSH-windows-arm64.zip"
            origin, friendly = "YPSH-windows-arm64.exe", "Windows ARM"
        else:
            return err(f"Unsupported CPU: {arch}")
        final, gate = "ypsh.exe", False
    else:
        return err(f"Unsupported OS: {system}")

    return {
        "status": "ok",
        "platform": friendly,
        "url": dl,
        "origin_filename": origin,
        "recommended_filename": final,
        "isGatekeeperCommandRequire": gate,
    }


def _add_to_path_posix(path_dir: str) -> list[str]:
    home = os.path.expanduser("~")
    shell = os.path.basename(os.environ.get("SHELL", "bash")).lower()

    def contains(p: str) -> bool:
        try:
            with open(p, "r", encoding="utf-8", errors="ignore") as fh:
                txt = fh.read()
            return path_dir in txt
        except FileNotFoundError:
            return False
        except Exception:
            return False

    all_known = [
        os.path.join(home, ".zprofile"),
        os.path.join(home, ".zshrc"),
        os.path.join(home, ".bash_profile"),
        os.path.join(home, ".bashrc"),
        os.path.join(home, ".profile"),
    ]
    if any(contains(f) for f in all_known):
        return []

    if "zsh" in shell:
        candidates = [os.path.join(home, ".zprofile"), os.path.join(home, ".zshrc")]
    elif "bash" in shell:
        candidates = [os.path.join(home, ".bash_profile"), os.path.join(home, ".bashrc")]
    else:
        candidates = [os.path.join(home, ".profile")]

    updated: list[str] = []

    if not any(os.path.exists(p) for p in candidates):
        target = candidates[0]
        os.makedirs(os.path.dirname(target), exist_ok=True)
        with open(target, "a", encoding="utf-8") as fh:
            fh.write(f'\n# Added by YPSH installer\nexport PATH="{path_dir}:$PATH"\n')
        return [target]

    for p in candidates:
        if os.path.exists(p) and not contains(p):
            with open(p, "a", encoding="utf-8") as fh:
                fh.write(f'\n# Added by YPSH installer\nexport PATH="{path_dir}:$PATH"\n')
            updated.append(p)

    return updated

def _add_to_path_windows(path_dir: str) -> bool:
    try:
        import winreg  # type: ignore
        import ctypes

        key_path = r"Environment"
        with winreg.OpenKey(winreg.HKEY_CURRENT_USER, key_path, 0, winreg.KEY_READ | winreg.KEY_WRITE) as key:
            try:
                existing, _ = winreg.QueryValueEx(key, "Path")
            except FileNotFoundError:
                existing = ""
            parts = [p for p in existing.split(";") if p]
            lower = [p.lower() for p in parts]
            if path_dir.lower() in lower:
                changed = False
            else:
                new_val = (existing + (";" if existing and not existing.endswith(";") else "") + path_dir)
                winreg.SetValueEx(key, "Path", 0, winreg.REG_EXPAND_SZ, new_val)
                changed = True

        if changed:
            HWND_BROADCAST = 0xFFFF
            WM_SETTINGCHANGE = 0x001A
            SMTO_ABORTIFHUNG = 0x0002
            ctypes.windll.user32.SendMessageTimeoutW(
                HWND_BROADCAST, WM_SETTINGCHANGE, 0, "Environment", SMTO_ABORTIFHUNG, 5000, None
            )
        return changed
    except Exception:
        return False


def add_to_user_path(path_dir: str) -> str:
    system = platform.system()
    if system in ("Darwin", "Linux"):
        updated = _add_to_path_posix(path_dir)
        if updated:
            return "PATH updated in: " + ", ".join(os.path.basename(u) for u in updated)
        return "PATH already contained install dir (or update not needed)."
    elif system == "Windows":
        ok = _add_to_path_windows(path_dir)
        return "PATH updated for current user." if ok else "PATH already contained install dir (or update failed)."
    else:
        return "PATH update not supported on this OS."


def install(
    *,
    to: str,
    channel: Channel,
    custom_tag: str | None,
    ignoreGatekeeper: bool,
    debug: bool,
    add_to_path_flag: bool = True,
    log_cb: Optional[Callable[[str], None]] = None,
    progress_cb: Optional[Callable[[int], None]] = None,
) -> Dict[str, Any]:
    def log(msg: str) -> None:
        if log_cb:
            log_cb(msg)
        if debug:
            print(f"{msg}")

    def setprog(v: int) -> None:
        if progress_cb:
            try:
                progress_cb(max(0, min(100, int(v))))
            except Exception:
                pass

    setprog(1)
    log("Resolving release tag…")
    tag = custom_tag if channel == "custom" else getTagFromChannel(channel)

    info = getAutoBuildInfomation(tag)
    if info.get("status") == "error":
        return info

    gate = False if ignoreGatekeeper else info["isGatekeeperCommandRequire"]

    with tempfile.TemporaryDirectory() as tmp:
        zpath = os.path.join(tmp, "ypsh.zip")
        url = info["url"]
        log(f"Downloading: {url}")

        setprog(5)
        with requests.get(url, timeout=60, stream=True) as r:
            r.raise_for_status()
            total = int(r.headers.get("Content-Length", "0")) or None
            got = 0
            chunk = 1024 * 128
            with open(zpath, "wb") as fp:
                for data in r.iter_content(chunk_size=chunk):
                    if not data:
                        continue
                    fp.write(data)
                    got += len(data)
                    if total:
                        setprog(5 + int(65 * (got / total)))

        log("Extracting archive…")
        setprog(75)
        with zipfile.ZipFile(zpath) as zf:
            zf.extract(info["origin_filename"], tmp)

        src = os.path.join(tmp, info["origin_filename"])
        os.makedirs(to, exist_ok=True)
        dst = os.path.join(to, info["recommended_filename"])

        log(f"Installing to: {dst}")
        shutil.copy2(src, dst)
        os.chmod(dst, 0o755)
        setprog(88)

        if gate:
            log("Clearing macOS quarantine flag (Gatekeeper)…")
            passingGatekeeper(dst)

        setprog(92)

        if add_to_path_flag:
            log("Adding install directory to PATH for future sessions…")
            outcome = add_to_user_path(to)
            log(f"{outcome}")

        setprog(100)

    return {"status": "ok", "dest": to, "binary": info["recommended_filename"]}


# ─────────────────────────────────────────────────────────────────────────────
# CLI
# ─────────────────────────────────────────────────────────────────────────────

def run_cli(argv: list[str]) -> None:
    opts: Dict[str, Any] = {}
    nxt: str | None = None
    for a in argv:
        k = a.lstrip("-").lower()
        if nxt:
            opts[nxt] = a
            nxt = None
            continue
        if k in ("c", "ch", "channel"):
            nxt = "channel"
        elif k in ("tag", "t", "v", "version"):
            nxt = "custom_tag"
        elif k in ("to", "dest"):
            nxt = "to"
        elif k in ("d", "debug", "ve", "verbose"):
            opts["debug"] = True
        elif k in ("ig", "ignoregatekeeper"):
            opts["ignoreGatekeeper"] = True
        elif k in ("noaddpath", "no-path", "no-path-add"):
            opts["add_to_path_flag"] = False
        elif k in ("addpath", "path"):
            opts["add_to_path_flag"] = True

    res = install(
        to=opts.get("to", DEFAULT_DEST),
        channel=opts.get("channel", "stable"),
        custom_tag=opts.get("custom_tag"),
        ignoreGatekeeper=opts.get("ignoreGatekeeper", False),
        debug=opts.get("debug", False),
        add_to_path_flag=opts.get("add_to_path_flag", True),
        log_cb=lambda s: print(s),
        progress_cb=None,
    )
    if res.get("status") == "ok":
        print(f"[green]Installation successful[/green] → {res.get('dest')}")
    else:
        print(f"[red]Failed:[/red] {res.get('desc')}")


# ─────────────────────────────────────────────────────────────────────────────
# GUI with i18n
# ─────────────────────────────────────────────────────────────────────────────

try:
    from PySide6.QtCore import Qt, QThread, Signal, Slot
    from PySide6.QtGui import QPalette, QColor, QPixmap, QIcon
    from PySide6.QtWidgets import (
        QApplication,
        QWizard,
        QWizardPage,
        QLabel,
        QTextEdit,
        QLineEdit,
        QVBoxLayout,
        QHBoxLayout,
        QPushButton,
        QRadioButton,
        QButtonGroup,
        QFileDialog,
        QProgressBar,
        QCheckBox,
        QWidget,
        QSpacerItem,
        QSizePolicy,
        QStyleFactory,
        QMessageBox,
        QListWidget,
        QListWidgetItem,
        QFormLayout,
        QFrame,
        QComboBox,
    )

    PYSIDE_AVAILABLE = True
except ModuleNotFoundError:
    PYSIDE_AVAILABLE = False


# ── i18n ────────────────────────────────────────────────────────────────────

from PySide6.QtCore import QObject


class I18n(QObject):
    languageChanged = Signal()

    def __init__(self, lang: str = "en"):
        super().__init__()
        self.lang = lang
        self._s: dict[str, dict[str, str]] = {
            "en": {
                "app_title": "YPSH Setup",
                "brand": "YPSH",
                "language": "Language",
                "lang_en": "English",
                "lang_ja": "日本語",

                "welcome_title": "Welcome to YPSH Setup",
                "welcome_msg": "This wizard will install YPSH on your system. Click “Next” to continue.",
                "tip_1": "No admin privileges required (installs to your user directory)",
                "tip_2": "Adding to PATH is optional",
                "tip_3": "On macOS, quarantine (Gatekeeper) can be cleared",

                "license_title": "License Agreement",
                "license_reload": "Reload",
                "license_accept": "I accept the license terms",
                "license_loading": "Fetching license text…",
                "license_error": "Failed to fetch license.\nClick “Reload” to try again.\n\n{err}",

                "channel_title": "Choose a Release Channel",
                "stable": "Stable (recommended)",
                "beta": "Beta (early features)",
                "custom": "Custom (specify tag)",
                "channel_hint": "If you choose Custom, you will enter an exact release tag (e.g., v1.2.3) on the next page.",

                "custom_title": "Specify Custom Tag",
                "custom_label": "Tag:",
                "custom_placeholder": "e.g., v1.2.3",
                "custom_note": "Enter an exact release tag.",

                "dest_title": "Choose Installation Directory",
                "browse": "Browse…",
                "dest_note": "If the folder does not exist, it will be created. Installing under your home directory is recommended.",

                "options_title": "Advanced Options",
                "opt_path": "Add YPSH folder to PATH (recommended)",
                "opt_gate": "Do not clear Gatekeeper quarantine (macOS)",
                "opt_debug": "Enable verbose logging (debug)",
                "options_hint": "Click “Next” to review your choices.",

                "summary_title": "Review",
                "summary_intro": "The installer will run with the following settings:",
                "summary_channel": "• Channel: {channel}",
                "summary_tag": "• Tag: {tag}",
                "summary_dest": "• Destination: {dest}",
                "summary_addpath": "• Add to PATH: {yn}",
                "summary_gate": "• Gatekeeper quarantine removal: {gate}",
                "summary_debug": "• Debug: {dbg}",
                "yes": "Yes",
                "no": "No",
                "gate_do": "Remove when needed",
                "gate_dont": "Do not remove",

                "install_title": "Installing…",
                "install_logs_ph": "Logs will appear here…",
                "install_failed": "Installation failed",
                "error_unknown": "Unknown error",

                "finish_title": "Completed",
                "finish_msg": "YPSH has been installed.\nDestination: {dest}",
                "finish_open": "Open install folder",
                "finish_copy": "Copy launch command",
                "finish_hint": "Open a new terminal to pick up PATH changes.",
                "copied_title": "Copied",
                "copied_body": "Copied the following command to clipboard:\n{cmd}",

                "btn_next": "Next",
                "btn_back": "Back",
                "btn_cancel": "Cancel",
                "btn_finish": "Finish",
            },
            "ja": {
                "app_title": "YPSH セットアップ",
                "brand": "YPSH",
                "language": "言語",
                "lang_en": "English",
                "lang_ja": "日本語",

                "welcome_title": "YPSH セットアップへようこそ",
                "welcome_msg": "このウィザードは YPSH をシステムにインストールします。“次へ”を押して進みます。",
                "tip_1": "管理者権限は不要です（ユーザーディレクトリへ展開）",
                "tip_2": "PATH への追加は任意です",
                "tip_3": "macOS では Gatekeeper の隔離属性を解除可能",

                "license_title": "ライセンスに同意",
                "license_reload": "再読み込み",
                "license_accept": "ライセンスに同意します",
                "license_loading": "ライセンス文を取得中…",
                "license_error": "ライセンスの取得に失敗しました。“再読み込み”で再試行してください。\n\n{err}",

                "channel_title": "リリースチャンネルを選択",
                "stable": "Stable（安定版・推奨）",
                "beta": "Beta（新機能の早期提供）",
                "custom": "Custom（タグを指定）",
                "channel_hint": "Custom を選ぶと次ページで正確なタグ（例: v1.2.3）を入力します。",

                "custom_title": "カスタムタグの指定",
                "custom_label": "タグ:",
                "custom_placeholder": "例: v1.2.3",
                "custom_note": "正確なリリースタグを入力してください。",

                "dest_title": "インストール先を選択",
                "browse": "参照…",
                "dest_note": "存在しない場合はフォルダを作成します。ホーム配下を推奨します。",

                "options_title": "オプション",
                "opt_path": "YPSH フォルダを PATH に追加（推奨）",
                "opt_gate": "Gatekeeper の隔離属性を解除しない（macOS）",
                "opt_debug": "詳細ログ（デバッグ）を有効化",
                "options_hint": "“次へ”で内容を確認できます。",

                "summary_title": "内容の確認",
                "summary_intro": "以下の設定でインストールを実行します。",
                "summary_channel": "• チャンネル: {channel}",
                "summary_tag": "• タグ: {tag}",
                "summary_dest": "• インストール先: {dest}",
                "summary_addpath": "• PATH に追加: {yn}",
                "summary_gate": "• Gatekeeper 解除: {gate}",
                "summary_debug": "• デバッグ: {dbg}",
                "yes": "はい",
                "no": "いいえ",
                "gate_do": "する（必要時）",
                "gate_dont": "しない",

                "install_title": "インストールの進行状況",
                "install_logs_ph": "ここにログが表示されます…",
                "install_failed": "インストール失敗",
                "error_unknown": "不明なエラー",

                "finish_title": "完了",
                "finish_msg": "YPSH のインストールが完了しました。\nインストール先: {dest}",
                "finish_open": "インストール先を開く",
                "finish_copy": "起動コマンドをコピー",
                "finish_hint": "新しいターミナルを開くと PATH の更新が反映されます。",
                "copied_title": "コピーしました",
                "copied_body": "次のコマンドをクリップボードにコピーしました:\n{cmd}",

                "btn_next": "次へ",
                "btn_back": "戻る",
                "btn_cancel": "キャンセル",
                "btn_finish": "完了",
            },
        }

    def t(self, key: str, **kw) -> str:
        s = self._s.get(self.lang, {}).get(key, key)
        return s.format(**kw)

    def set_lang(self, lang: str) -> None:
        if lang not in self._s:
            return
        if lang != self.lang:
            self.lang = lang
            self.languageChanged.emit()


# ── GUI State ───────────────────────────────────────────────────────────────

@dataclass
class WizardState:
    channel: Channel = "stable"
    custom_tag: str | None = None
    dest: str = DEFAULT_DEST
    add_path: bool = True
    ignore_gatekeeper: bool = False
    debug: bool = False


if PYSIDE_AVAILABLE:

    # ── Workers ────────────────────────────────────────────────────────────

    class LicenseWorker(QThread):
        done = Signal(str, bool, str)  # text, ok, error

        def __init__(self, url: str):
            super().__init__()
            self.url = url

        def run(self) -> None:
            try:
                r = requests.get(self.url, timeout=10)
                r.raise_for_status()
                self.done.emit(r.text, True, "")
            except Exception as e:
                self.done.emit("", False, str(e))

    class InstallWorker(QThread):
        log = Signal(str)
        progress = Signal(int)
        finished = Signal(dict)

        def __init__(self, state: WizardState):
            super().__init__()
            self.state = state

        def run(self) -> None:
            self.log.emit("Installation started…")
            try:
                out = install(
                    to=self.state.dest,
                    channel=self.state.channel,
                    custom_tag=self.state.custom_tag,
                    ignoreGatekeeper=self.state.ignore_gatekeeper,
                    debug=self.state.debug,
                    add_to_path_flag=self.state.add_path,
                    log_cb=self.log.emit,
                    progress_cb=self.progress.emit,
                )
                ok = out.get("status") == "ok"
                self.log.emit("Finished: " + ("SUCCESS" if ok else "FAIL"))
            except Exception:
                out = {"status": "error", "desc": "Unhandled"}
                self.log.emit(traceback.format_exc())
            self.finished.emit(out)

    # ── UI Utils ───────────────────────────────────────────────────────────

    def apply_dark_palette(app: QApplication) -> None:
        try:
            app.setStyle(QStyleFactory.create("Fusion"))
        except Exception:
            pass

        palette = QPalette()
        palette.setColor(QPalette.Window, QColor("#0e1116"))
        palette.setColor(QPalette.Base, QColor("#0b0e14"))
        palette.setColor(QPalette.AlternateBase, QColor("#11151c"))
        palette.setColor(QPalette.ToolTipBase, QColor("#11151c"))
        palette.setColor(QPalette.ToolTipText, QColor("#e6edf3"))
        palette.setColor(QPalette.Text, QColor("#e6edf3"))
        palette.setColor(QPalette.WindowText, QColor("#e6edf3"))
        palette.setColor(QPalette.Button, QColor("#1f6feb"))
        palette.setColor(QPalette.ButtonText, QColor("#ffffff"))
        palette.setColor(QPalette.Highlight, QColor("#2f81f7"))
        palette.setColor(QPalette.HighlightedText, QColor("#ffffff"))
        palette.setColor(QPalette.PlaceholderText, QColor("#9aa4b2"))
        app.setPalette(palette)

    BASE_QSS = """
    QWizard { background: #0e1116; }
    QWizard QWidget { color: #e6edf3; font-size: 14px; }
    QWizard QLabel#Brand {
        font-size: 40px; font-weight: 800; color: #e6edf3;
        letter-spacing: 1px; margin: 8px 0 16px 0;
    }
    QWizardPage {
        background: qlineargradient(x1:0,y1:0,x2:1,y2:0, stop:0 #11151c, stop:1 #0e1116);
        border: 1px solid #232936; border-radius: 12px;
        padding: 16px; margin: 12px;
    }
    QLineEdit, QTextEdit {
        background: #0b0e14; border: 1px solid #2b3343; border-radius: 8px;
        padding: 8px; selection-background-color: #2f81f7;
    }
    QCheckBox, QRadioButton { spacing: 8px; }
    QPushButton {
        border-radius: 10px; padding: 8px 14px; background: #1f6feb; color: white; border: none;
    }
    QPushButton:hover { background: #2b80ff; }
    QPushButton:disabled { background: #2b3343; color: #9aa4b2; }
    QProgressBar {
        background: #0b0e14; border: 1px solid #2b3343; border-radius: 8px; text-align: center;
    }
    QProgressBar::chunk { background-color: #2f81f7; border-radius: 8px; margin: 1px; }
    QFrame#line { background: #232936; min-height: 1px; max-height: 1px; }
    """

    class LanguageSwitcher(QWidget):
        def __init__(self, i18n: I18n, parent=None):
            super().__init__(parent)
            self.i18n = i18n
            lay = QHBoxLayout(self)
            lay.setContentsMargins(0, 0, 0, 0)
            self.lbl = QLabel()
            self.cmb = QComboBox()
            self.cmb.addItem("English", "en")
            self.cmb.addItem("日本語", "ja")
            self.cmb.setCurrentIndex(0)  # default: English
            self.cmb.currentIndexChanged.connect(self._on_changed)
            lay.addStretch(1)
            lay.addWidget(self.lbl)
            lay.addWidget(self.cmb)
            self.i18n.languageChanged.connect(self._apply)
            self._apply()

        def _on_changed(self, idx: int):
            lang = self.cmb.currentData()
            self.i18n.set_lang(lang)

        def _apply(self):
            self.lbl.setText(self.i18n.t("language"))

            # Keep combo labels localized too
            self.cmb.blockSignals(True)
            self.cmb.setItemText(0, self.i18n.t("lang_en"))
            self.cmb.setItemText(1, self.i18n.t("lang_ja"))
            # Keep selection as is
            self.cmb.blockSignals(False)

    class StyledPage(QWizardPage):
        def __init__(self, i18n: I18n, title_key: str = ""):
            super().__init__()
            self.i18n = i18n
            self._title_key = title_key
            self.i18n.languageChanged.connect(self._apply_title)
            self._apply_title()

        def _apply_title(self):
            if self._title_key:
                self.setTitle(self.i18n.t(self._title_key))

        # For pages to override and update their texts
        def apply_texts(self):
            pass

    # ── Pages ───────────────────────────────────────────────────────────────

    class WelcomePage(StyledPage):
        def __init__(self, i18n: I18n):
            super().__init__(i18n, "welcome_title")
            v = QVBoxLayout(self)

            # Top-right language switcher
            v.addWidget(LanguageSwitcher(i18n))

            brand = QLabel()
            brand.setObjectName("Brand")
            brand.setAlignment(Qt.AlignCenter)

            self.msg = QLabel()
            self.msg.setWordWrap(True)
            self.msg.setAlignment(Qt.AlignCenter)

            v.addWidget(brand)
            v.addWidget(self.msg)
            v.addItem(QSpacerItem(0, 8, QSizePolicy.Minimum, QSizePolicy.Fixed))

            tips = QListWidget()
            tips.setFrameShape(QListWidget.NoFrame)
            tips.setSpacing(4)
            self._tips = tips
            v.addWidget(tips)

            self._brand = brand
            self.i18n.languageChanged.connect(self.apply_texts)
            self.apply_texts()

        def apply_texts(self):
            self._brand.setText(self.i18n.t("brand"))
            self.msg.setText(self.i18n.t("welcome_msg"))
            self._tips.clear()
            for t in ["tip_1", "tip_2", "tip_3"]:
                QListWidgetItem(f"• {self.i18n.t(t)}", self._tips)

    class LicensePage(StyledPage):
        LICENSE_URL = "https://ypsh-dgc.github.io/YPSH/LICENSE"

        def __init__(self, i18n: I18n):
            super().__init__(i18n, "license_title")
            self.worker: Optional[LicenseWorker] = None

            v = QVBoxLayout(self)
            v.addWidget(LanguageSwitcher(i18n))

            self.reload_btn = QPushButton()
            self.reload_btn.clicked.connect(self._reload)

            top = QHBoxLayout()
            top.addStretch(1)
            top.addWidget(self.reload_btn)
            v.addLayout(top)

            self.view = QTextEdit()
            self.view.setReadOnly(True)
            v.addWidget(self.view, 1)

            self.chk_accept = QCheckBox()
            self.chk_accept.stateChanged.connect(self.completeChanged)
            v.addWidget(self.chk_accept)

            self.i18n.languageChanged.connect(self.apply_texts)
            self.apply_texts()

        def initializePage(self) -> None:
            self._reload()

        def isComplete(self) -> bool:
            return self.chk_accept.isChecked() and bool(self.view.toPlainText().strip())

        @Slot()
        def _reload(self) -> None:
            self.setEnabled(False)
            self.view.setPlainText(self.i18n.t("license_loading"))
            self.worker = LicenseWorker(self.LICENSE_URL)
            self.worker.done.connect(self._on_done)
            self.worker.start()

        @Slot(str, bool, str)
        def _on_done(self, text: str, ok: bool, err: str) -> None:
            self.setEnabled(True)
            if ok:
                self.view.setPlainText(text)
            else:
                self.view.setPlainText(self.i18n.t("license_error", err=err))
                QMessageBox.warning(self, self.i18n.t("license_title"), self.i18n.t("license_error", err=err))
            self.completeChanged.emit()

        def apply_texts(self):
            self.reload_btn.setText(self.i18n.t("license_reload"))
            self.chk_accept.setText(self.i18n.t("license_accept"))
            if self.view.toPlainText().strip() == "" or "Fetching" in self.view.toPlainText() or "取得中" in self.view.toPlainText():
                self.view.setPlaceholderText(self.i18n.t("license_loading"))

    class ChannelPage(StyledPage):
        def __init__(self, i18n: I18n, state: WizardState):
            super().__init__(i18n, "channel_title")
            self.state = state
            v = QVBoxLayout(self)
            v.addWidget(LanguageSwitcher(i18n))

            self.grp = QButtonGroup(self)

            self.rad_stable = QRadioButton()
            self.rad_beta = QRadioButton()
            self.rad_custom = QRadioButton()
            self.rad_stable.setChecked(True)

            for i, w in enumerate([self.rad_stable, self.rad_beta, self.rad_custom]):
                self.grp.addButton(w, i)
                v.addWidget(w)

            self.hint = QLabel()
            self.hint.setWordWrap(True)
            v.addWidget(self.hint)

            self.i18n.languageChanged.connect(self.apply_texts)
            self.apply_texts()

        def validatePage(self) -> bool:
            if self.rad_stable.isChecked():
                self.state.channel = "stable"
            elif self.rad_beta.isChecked():
                self.state.channel = "beta"
            else:
                self.state.channel = "custom"
            return True

        def nextId(self) -> int:
            wiz: InstallerWizard = self.wizard()  # type: ignore
            return wiz.Page_CustomTag if self.rad_custom.isChecked() else wiz.Page_Destination

        def apply_texts(self):
            self.rad_stable.setText(self.i18n.t("stable"))
            self.rad_beta.setText(self.i18n.t("beta"))
            self.rad_custom.setText(self.i18n.t("custom"))
            self.hint.setText(self.i18n.t("channel_hint"))

    class CustomTagPage(StyledPage):
        def __init__(self, i18n: I18n, state: WizardState):
            super().__init__(i18n, "custom_title")
            self.state = state
            v = QVBoxLayout(self)
            v.addWidget(LanguageSwitcher(i18n))

            form = QFormLayout()
            self.lbl = QLabel()
            self.edit = QLineEdit()
            form.addRow(self.lbl, self.edit)
            v.addLayout(form)

            self.note = QLabel()
            self.note.setWordWrap(True)
            v.addWidget(self.note)

            self.i18n.languageChanged.connect(self.apply_texts)
            self.apply_texts()

            self.edit.textChanged.connect(self.completeChanged)

        def isComplete(self) -> bool:
            return bool(self.edit.text().strip())

        def validatePage(self) -> bool:
            self.state.custom_tag = self.edit.text().strip()
            return True

        def apply_texts(self):
            self.lbl.setText(self.i18n.t("custom_label"))
            self.edit.setPlaceholderText(self.i18n.t("custom_placeholder"))
            self.note.setText(self.i18n.t("custom_note"))

    class DestinationPage(StyledPage):
        def __init__(self, i18n: I18n, state: WizardState):
            super().__init__(i18n, "dest_title")
            self.state = state
            v = QVBoxLayout(self)
            v.addWidget(LanguageSwitcher(i18n))

            row = QHBoxLayout()
            self.edit = QLineEdit(DEFAULT_DEST)
            self.btn = QPushButton()
            self.btn.clicked.connect(self._browse)
            row.addWidget(self.edit, 1)
            row.addWidget(self.btn)
            v.addLayout(row)

            self.note = QLabel()
            self.note.setWordWrap(True)
            v.addWidget(self.note)

            self.i18n.languageChanged.connect(self.apply_texts)
            self.apply_texts()

        @Slot()
        def _browse(self) -> None:
            d = QFileDialog.getExistingDirectory(self, self.i18n.t("dest_title"), self.edit.text())
            if d:
                self.edit.setText(d)

        def validatePage(self) -> bool:
            path = self.edit.text().strip() or DEFAULT_DEST
            self.state.dest = path
            return True

        def apply_texts(self):
            self.btn.setText(self.i18n.t("browse"))
            self.note.setText(self.i18n.t("dest_note"))

    class OptionsPage(StyledPage):
        def __init__(self, i18n: I18n, state: WizardState):
            super().__init__(i18n, "options_title")
            self.state = state
            v = QVBoxLayout(self)
            v.addWidget(LanguageSwitcher(i18n))

            self.chk_path = QCheckBox()
            self.chk_path.setChecked(True)
            self.chk_gate = QCheckBox()
            self.chk_gate.setChecked(False)
            self.chk_dbg = QCheckBox()
            self.chk_dbg.setChecked(False)

            v.addWidget(self.chk_path)
            v.addWidget(self.chk_gate)
            v.addWidget(self.chk_dbg)

            v.addWidget(self._hline())
            self.hint = QLabel()
            self.hint.setWordWrap(True)
            v.addWidget(self.hint)

            self.i18n.languageChanged.connect(self.apply_texts)
            self.apply_texts()

        def _hline(self) -> QFrame:
            line = QFrame()
            line.setObjectName("line")
            line.setFrameShape(QFrame.HLine)
            line.setFrameShadow(QFrame.Sunken)
            return line

        def validatePage(self) -> bool:
            self.state.add_path = self.chk_path.isChecked()
            self.state.ignore_gatekeeper = self.chk_gate.isChecked()
            self.state.debug = self.chk_dbg.isChecked()
            return True

        def apply_texts(self):
            self.chk_path.setText(self.i18n.t("opt_path"))
            self.chk_gate.setText(self.i18n.t("opt_gate"))
            self.chk_dbg.setText(self.i18n.t("opt_debug"))
            self.hint.setText(self.i18n.t("options_hint"))

    class SummaryPage(StyledPage):
        def __init__(self, i18n: I18n, state: WizardState):
            super().__init__(i18n, "summary_title")
            self.state = state
            self.view = QTextEdit()
            self.view.setReadOnly(True)
            v = QVBoxLayout(self)
            v.addWidget(LanguageSwitcher(i18n))
            v.addWidget(self.view)
            self.i18n.languageChanged.connect(self.apply_texts)

        def initializePage(self) -> None:
            self.apply_texts()

        def nextId(self) -> int:
            return self.wizard().Page_Install  # type: ignore

        def apply_texts(self):
            lines = [self.i18n.t("summary_intro"), ""]
            lines.append(self.i18n.t("summary_channel", channel=self.state.channel))
            if self.state.channel == "custom" and self.state.custom_tag:
                lines.append(self.i18n.t("summary_tag", tag=self.state.custom_tag))
            lines.append(self.i18n.t("summary_dest", dest=self.state.dest))
            lines.append(self.i18n.t("summary_addpath", yn=self.i18n.t("yes") if self.state.add_path else self.i18n.t("no")))
            gate_txt = self.i18n.t("gate_dont") if self.state.ignore_gatekeeper else self.i18n.t("gate_do")
            lines.append(self.i18n.t("summary_gate", gate=gate_txt))
            lines.append(self.i18n.t("summary_debug", dbg=self.i18n.t("yes") if self.state.debug else self.i18n.t("no")))
            self.view.setPlainText("\n".join(lines))

    class InstallPage(StyledPage):
        def __init__(self, i18n: I18n, state: WizardState):
            super().__init__(i18n, "install_title")
            self.state = state
            self.worker: Optional[InstallWorker] = None

            v = QVBoxLayout(self)
            v.addWidget(LanguageSwitcher(i18n))

            self.prg = QProgressBar()
            self.prg.setRange(0, 100)
            self.log = QTextEdit()
            self.log.setReadOnly(True)

            v.addWidget(self.prg)
            v.addWidget(self.log, 1)

            self.i18n.languageChanged.connect(self.apply_texts)
            self.apply_texts()

        def initializePage(self) -> None:
            wiz: InstallerWizard = self.wizard()  # type: ignore
            for btn in (QWizard.BackButton, QWizard.NextButton):
                w = wiz.button(btn)
                if w:
                    w.setEnabled(False)

            self.worker = InstallWorker(self.state)
            self.worker.log.connect(self.log.append)
            self.worker.progress.connect(self.prg.setValue)
            self.worker.finished.connect(self._done)
            self.worker.start()

        @Slot(dict)
        def _done(self, res: Dict[str, Any]) -> None:
            wiz: InstallerWizard = self.wizard()  # type: ignore
            ok = res.get("status") == "ok"
            self.prg.setValue(100)
            if ok:
                wiz.setProperty("result", res)
                nxt = wiz.button(QWizard.NextButton)
                if nxt:
                    nxt.setEnabled(True)
                    nxt.click()
            else:
                back = wiz.button(QWizard.BackButton)
                if back:
                    back.setEnabled(True)
                cancel = wiz.button(QWizard.CancelButton)
                if cancel:
                    cancel.setEnabled(True)
                    cancel.setVisible(True)
                QMessageBox.critical(self, self.i18n.t("install_failed"), res.get("desc", self.i18n.t("error_unknown")))

        def nextId(self) -> int:
            return self.wizard().Page_Finish  # type: ignore

        def apply_texts(self):
            self.log.setPlaceholderText(self.i18n.t("install_logs_ph"))

    class FinishPage(StyledPage):
        def __init__(self, i18n: I18n, state: WizardState):
            super().__init__(i18n, "finish_title")
            self.state = state
            v = QVBoxLayout(self)
            v.addWidget(LanguageSwitcher(i18n))

            self.msg = QLabel()
            self.msg.setWordWrap(True)
            v.addWidget(self.msg)

            row = QHBoxLayout()
            row.addStretch(1)
            self.btn_open = QPushButton()
            self.btn_copy_cmd = QPushButton()
            row.addWidget(self.btn_open)
            row.addWidget(self.btn_copy_cmd)
            v.addLayout(row)

            self.hint = QLabel()
            self.hint.setWordWrap(True)
            v.addWidget(self.hint)

            self.btn_open.clicked.connect(self._open_folder)
            self.btn_copy_cmd.clicked.connect(self._copy_cmd)

            self.i18n.languageChanged.connect(self.apply_texts)
            # ★ ここで apply_texts は呼ばない（wizard() がまだ None のため）
            # self.apply_texts()

        def initializePage(self) -> None:
            # ページがウィザードに組み込まれた後に呼ばれるので安全
            self.apply_texts()

        @Slot()
        def _open_folder(self) -> None:
            dest = self.state.dest
            if platform.system() == "Windows":
                os.startfile(dest)  # type: ignore
            elif platform.system() == "Darwin":
                os.system(f'open "{dest}"')
            else:
                os.system(f'xdg-open "{dest}"')

        @Slot()
        def _copy_cmd(self) -> None:
            bin_name = "ypsh.exe" if platform.system() == "Windows" else "ypsh"
            cmd = os.path.join(self.state.dest, bin_name)
            QApplication.clipboard().setText(cmd)
            QMessageBox.information(self, self.i18n.t("copied_title"), self.i18n.t("copied_body", cmd=cmd))

        def isFinalPage(self) -> bool:
            return True

        def apply_texts(self):
            # ★ wizard() が None のケースに対応
            dest = self.state.dest
            wiz = self.wizard()
            if wiz is not None:
                res = wiz.property("result")
                if isinstance(res, dict):
                    dest = res.get("dest", dest)

            self.setTitle(self.i18n.t("finish_title"))
            self.msg.setText(self.i18n.t("finish_msg", dest=dest))
            self.btn_open.setText(self.i18n.t("finish_open"))
            self.btn_copy_cmd.setText(self.i18n.t("finish_copy"))
            self.hint.setText(self.i18n.t("finish_hint"))

    # ── Wizard ──────────────────────────────────────────────────────────────

    class InstallerWizard(QWizard):
        Page_Welcome, Page_License, Page_Channel, Page_CustomTag, Page_Destination, Page_Options, Page_Summary, Page_Install, Page_Finish = range(9)

        def __init__(self):
            super().__init__()
            self.i18n = I18n(lang="en")  # default English
            self.state = WizardState()

            self.setWindowTitle(self.i18n.t("app_title"))
            self.setWizardStyle(QWizard.ModernStyle)
            self.setMinimumSize(760, 560)
            self.setPixmap(QWizard.WatermarkPixmap, QPixmap())
            self.setPixmap(QWizard.LogoPixmap, QPixmap())
            self.setWindowIcon(QIcon())

            # Pages
            self.setPage(self.Page_Welcome, WelcomePage(self.i18n))
            self.setPage(self.Page_License, LicensePage(self.i18n))
            self.setPage(self.Page_Channel, ChannelPage(self.i18n, self.state))
            self.setPage(self.Page_CustomTag, CustomTagPage(self.i18n, self.state))
            self.setPage(self.Page_Destination, DestinationPage(self.i18n, self.state))
            self.setPage(self.Page_Options, OptionsPage(self.i18n, self.state))
            self.setPage(self.Page_Summary, SummaryPage(self.i18n, self.state))
            self.setPage(self.Page_Install, InstallPage(self.i18n, self.state))
            self.setPage(self.Page_Finish, FinishPage(self.i18n, self.state))

            self.setButtonLayout([
                QWizard.Stretch,
                QWizard.CancelButton,
                QWizard.BackButton,
                QWizard.NextButton,
                QWizard.FinishButton,
            ])

            self._apply_button_texts()
            self.setStyleSheet(BASE_QSS)

            self.i18n.languageChanged.connect(self._apply_i18n_all)

        def _apply_button_texts(self):
            self.setButtonText(QWizard.NextButton, self.i18n.t("btn_next"))
            self.setButtonText(QWizard.BackButton, self.i18n.t("btn_back"))
            self.setButtonText(QWizard.CancelButton, self.i18n.t("btn_cancel"))
            self.setButtonText(QWizard.FinishButton, self.i18n.t("btn_finish"))

        @Slot()
        def _apply_i18n_all(self):
            self.setWindowTitle(self.i18n.t("app_title"))
            self._apply_button_texts()
            # Titles & page content are updated by each page via languageChanged

        def nextId(self) -> int:
            cur = self.currentId()
            if cur == self.Page_Welcome:
                return self.Page_License
            if cur == self.Page_License:
                return self.Page_Channel
            if cur == self.Page_Channel:
                return super().nextId()
            if cur == self.Page_CustomTag:
                return self.Page_Destination
            if cur == self.Page_Destination:
                return self.Page_Options
            if cur == self.Page_Options:
                return self.Page_Summary
            if cur == self.Page_Summary:
                return self.Page_Install
            if cur == self.Page_Install:
                return self.Page_Finish
            return -1

    def launch_gui() -> None:
        app = QApplication(sys.argv)
        apply_dark_palette(app)
        w = InstallerWizard()
        w.show()
        sys.exit(app.exec())

else:

    def launch_gui() -> None:
        print("[yellow]PySide6 not found; using CLI.")
        run_cli([a for a in sys.argv[1:] if a != "cli"])


# ─────────────────────────────────────────────────────────────────────────────
# Entry
# ─────────────────────────────────────────────────────────────────────────────

if __name__ == "__main__":
    argv = sys.argv[1:]
    if "cli" in argv or not PYSIDE_AVAILABLE:
        if "cli" in argv:
            argv.remove("cli")
        run_cli(argv)
    else:
        launch_gui()
